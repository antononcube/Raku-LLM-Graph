use v6.d;
use Test;

# use lib <. lib>;
use LLM::Graph;
use Graph;

my %rules =
        fun1 => { eval-function => {'out1'} },
        fun2 => { eval-function => {'out2'} },
        combine => { eval-function => sub (Str:D $fun1, Str:D $fun2) { "$fun1 : $fun2" } }
        ;

subtest {
        ## 1
        ok LLM::Graph.new(%rules);

        ## 2
        my $g = LLM::Graph.new(%rules);
        isa-ok $g.create-graph.graph, Graph:D;

        ## 3
        is $g.eval.nodes<combine><result>, 'out1 : out2';

        ## 4
        is
                $g({fun1 => 'in1', fun2 => 'in2'}, nodes => 'judge').nodes<combine><result>,
                'in1 : in2',
                'overriding inputs and end-node spec; graph object is callable';

        ## 5
        is
                $g(fun1 => 'in1', fun2 => 'in2').nodes<combine><result>,
                'in1 : in2',
                'overriding inputs; graph object is callable';

}, 'graph creation and evaluations';

subtest {

        my $g = LLM::Graph.new(%rules);

        ok $g();

        is $g.nodes.nodemap(*<result>)<fun1 fun2 combine>, ['out1', 'out2', 'out1 : out2'];

        ok $g.clear(<fun1 fun2>);

        is $g.nodes.nodemap({ $_<result> // 'NONE' })<fun1 fun2 combine>, ['NONE', 'NONE', 'out1 : out2'];

        ok $g();
        is $g.clear('fun2').nodes.nodemap({ $_<result> // 'NONE' })<fun1 fun2 combine>, ['out1', 'NONE', 'out1 : out2'];

        ok $g();
        is $g.clear().nodes.nodemap({ $_<result> // 'NONE' })<fun1 fun2 combine>, ['NONE', 'NONE', 'NONE'];

}, 'drop results';

subtest {

        my %rules =
                poet1 => { eval-function => {'out1'} },
                poet2 => { eval-function => {'out2'} },
                poet3 => {
                        eval-function => {'out3'},
                        test-function => sub ($with-russian) { $with-russian ~~ Bool:D && $with-russian || $with-russian.Str.lc âˆˆ <true yes> }
                },
                judge => { eval-function => sub (Str:D $poet1, Str:D $poet2, Str:D $poet3) { $poet3.defined && $poet3 ?? $poet3 !! $poet2 } };

        ok LLM::Graph.new(%rules);

        my $g = LLM::Graph.new(%rules);

        ok $g();

        is $g.nodes.nodemap({ $_<result> // 'NONE' })<poet1 poet2 poet3 judge>, ['out1', 'out2', 'NONE', 'out2'];

        $g.clear();

        ok $g.eval(:with-russian);

        is $g.nodes.nodemap({ $_<result> // 'NONE' })<poet1 poet2 poet3 judge>, ['out1', 'out2', 'out3', 'out3'];

}, 'test function';

done-testing;
