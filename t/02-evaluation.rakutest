use v6.d;
use Test;

# use lib <. lib>;
use LLM::Graph;
use Graph;

my %rules =
        fun1 => { eval-function => {'out1'} },
        fun2 => { eval-function => {'out2'} },
        combine => { eval-function => sub (Str:D $fun1, Str:D $fun2) { "$fun1 : $fun2" } }
        ;

#subtest {
        ## 1
        ok LLM::Graph.new(%rules);

        ## 2
        my $g = LLM::Graph.new(%rules);
        isa-ok $g.create-graph.graph, Graph:D;

        ## 3
        is $g.eval.nodes<combine><result>, 'out1 : out2';

        ## 4
        is
                $g({fun1 => 'in1', fun2 => 'in2'}, nodes => 'judge').nodes<combine><result>,
                'in1 : in2',
                'overriding inputs and end-node spec; graph object is callable';

        ## 5
        is
                $g(fun1 => 'in1', fun2 => 'in2').nodes<combine><result>,
                'in1 : in2',
                'overriding inputs; graph object is callable';

#}, 'graph creation and evaluations';

subtest {

        my $g = LLM::Graph.new(%rules);

        ok $g();

        is $g.nodes.nodemap(*<result>)<fun1 fun2 combine>, ['out1', 'out2', 'out1 : out2'];

        ok $g.drop-result(<fun1 fun2>);

        is $g.nodes.nodemap({ $_<result> // 'NONE' })<fun1 fun2 combine>, ['NONE', 'NONE', 'out1 : out2'];

        ok $g();
        is $g.drop-result('fun2').nodes.nodemap({ $_<result> // 'NONE' })<fun1 fun2 combine>, ['out1', 'NONE', 'out1 : out2'];

        ok $g();
        is $g.drop-result().nodes.nodemap({ $_<result> // 'NONE' })<fun1 fun2 combine>, ['NONE', 'NONE', 'NONE'];

}, 'drop results';

done-testing;
